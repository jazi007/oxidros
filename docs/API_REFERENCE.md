# Oxidros API Reference

This document is auto-generated by `scripts/generate_api_docs.py`.

## Summary

| Category | Count |
|----------|-------|
| Common APIs | 32 |
| Zenoh-only APIs | 83 |
| RCL-only APIs | 148 |

---

## Common APIs (Both Backends)

These APIs are available in both `oxidros-rcl` and `oxidros-zenoh` with the same signature.

### logger

```rust
pub fn logger::init_ros_logging(name: &str)
pub mod logger
```

### parameter

```rust
pub struct parameter::ParameterServer
pub mod parameter
```

### root

```rust
pub mod oxidros_zenoh
```

### service

```rust
pub struct service::client::Client<T: ros2_types::traits::ServiceMsg>
pub struct service::server::ServiceRequest<T: ros2_types::traits::ServiceMsg>
pub mod service::client
pub fn service::client::Client<T>::fully_qualified_service_name(&self) -> oxidros_core::error::Result<alloc::borrow::Cow<'_, alloc::string::String>>
pub fn service::server::Server<T>::fully_qualified_service_name(&self) -> oxidros_core::error::Result<alloc::borrow::Cow<'_, alloc::string::String>>
pub fn service::client::Client<T>::is_service_available(&self) -> bool
pub fn service::server::ServiceRequest<T>::request(&self) -> &<T as ros2_types::traits::ServiceMsg>::Request
pub fn service::server::ServiceRequest<T>::respond(self, response: &<T as ros2_types::traits::ServiceMsg>::Response) -> oxidros_core::error::Result<()>
pub fn service::server::ServiceRequest<T>::send(self, response: &<T as ros2_types::traits::ServiceMsg>::Response) -> oxidros_core::error::Result<()>
pub mod service::server
pub mod service
pub fn service::client::Client<T>::service_name(&self) -> oxidros_core::error::Result<alloc::borrow::Cow<'_, alloc::string::String>>
pub fn service::server::Server<T>::service_name(&self) -> oxidros_core::error::Result<alloc::borrow::Cow<'_, alloc::string::String>>
pub fn service::server::ServiceRequest<T>::split(self) -> (service::server::RequestSender<T>, oxidros_core::message::Message<<T as ros2_types::traits::ServiceMsg>::Request>)
pub fn service::server::Server<T>::try_recv(&mut self) -> oxidros_core::error::Result<core::option::Option<Self::Request>>
```

### topic

```rust
pub struct topic::publisher::Publisher<T>
pub struct topic::subscriber::Subscriber<T>
pub fn topic::publisher::Publisher<T>::fully_qualified_topic_name(&self) -> &str
pub fn topic::subscriber::Subscriber<T>::fully_qualified_topic_name(&self) -> &str
pub mod topic::publisher
pub fn topic::subscriber::Subscriber<T>::recv_blocking(&self) -> oxidros_core::error::Result<oxidros_core::message::Message<T>>
pub fn topic::publisher::Publisher<T>::send(&self, msg: &T) -> oxidros_core::error::Result<()>
pub mod topic::subscriber
pub mod topic
pub fn topic::publisher::Publisher<T>::topic_name(&self) -> oxidros_core::error::Result<alloc::borrow::Cow<'_, alloc::string::String>>
pub fn topic::subscriber::Subscriber<T>::topic_name(&self) -> oxidros_core::error::Result<alloc::borrow::Cow<'_, alloc::string::String>>
pub fn topic::subscriber::Subscriber<T>::try_recv(&mut self) -> oxidros_core::error::Result<core::option::Option<oxidros_core::message::Message<T>>>
```

---

## Zenoh-Only APIs

These APIs are specific to `oxidros-zenoh`.

### Context

```rust
pub struct Context
pub type Context::Node = Node
pub type Context::Selector = Selector
pub fn Context::create_node(self: &alloc::sync::Arc<Self>, name: &str, namespace: core::option::Option<&str>) -> oxidros_core::error::Result<alloc::sync::Arc<Node>>
pub fn Context::create_selector(&self) -> Selector
pub fn Context::domain_id(&self) -> u32
pub fn Context::enclave(&self) -> core::option::Option<&str>
pub fn Context::graph_cache(&self) -> GraphCache
pub fn Context::new() -> oxidros_core::error::Result<alloc::sync::Arc<Self>>
pub fn Context::new_node(self: &alloc::sync::Arc<Self>, name: &str, namespace: core::option::Option<&str>) -> oxidros_core::error::Result<alloc::sync::Arc<Self::Node>>
pub fn Context::new_selector(self: &alloc::sync::Arc<Self>) -> oxidros_core::error::Result<Self::Selector>
pub fn Context::ros2_args(&self) -> &ros2args::types::Ros2Args
pub fn Context::ros_domain_id(&self) -> u32
pub fn Context::session(&self) -> &zenoh::api::session::Session
pub fn Context::session_id(&self) -> &str
pub fn Context::with_args(ros2_args: ros2args::types::Ros2Args) -> oxidros_core::error::Result<alloc::sync::Arc<Self>>
pub fn Context::with_args_and_domain_id(ros2_args: ros2args::types::Ros2Args, domain_id: u32) -> oxidros_core::error::Result<alloc::sync::Arc<Self>>
pub fn Context::with_config(domain_id: u32, config: zenoh::api::config::Config) -> oxidros_core::error::Result<alloc::sync::Arc<Self>>
pub fn Context::with_domain_id(domain_id: u32) -> oxidros_core::error::Result<alloc::sync::Arc<Self>>
pub fn Context::with_full_config(ros2_args: ros2args::types::Ros2Args, domain_id: u32, config: zenoh::api::config::Config) -> oxidros_core::error::Result<alloc::sync::Arc<Self>>
```

### GraphCache

```rust
pub struct GraphCache
pub fn GraphCache::count_publishers(&self, topic: &str) -> usize
pub fn GraphCache::count_subscribers(&self, topic: &str) -> usize
pub fn GraphCache::get_node_names(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn GraphCache::get_publishers_info(&self, topic: &str) -> alloc::vec::Vec<&graph_cache::EntityInfo>
pub fn GraphCache::get_subscribers_info(&self, topic: &str) -> alloc::vec::Vec<&graph_cache::EntityInfo>
pub fn GraphCache::handle_liveliness_token(&mut self, key_expr: &str, kind: zenoh::api::sample::SampleKind)
pub fn GraphCache::is_service_available(&self, service_name: &str) -> bool
pub fn GraphCache::new() -> Self
```

### Node

```rust
pub type Node::Client<T: ros2_types::traits::ServiceMsg> = service::client::Client<T>
pub struct Node
pub type Node::Publisher<T: ros2_types::traits::TypeSupport> = topic::publisher::Publisher<T>
pub type Node::Server<T: ros2_types::traits::ServiceMsg> = service::server::Server<T>
pub type Node::Subscriber<T: ros2_types::traits::TypeSupport> = topic::subscriber::Subscriber<T>
pub fn Node::context(&self) -> &alloc::sync::Arc<Context>
pub fn Node::create_parameter_server(self: &alloc::sync::Arc<Self>) -> oxidros_core::error::Result<parameter::ParameterServer>
pub fn Node::enclave(&self) -> &str
pub fn Node::expand_and_remap_name(&self, name: &str, kind: ros2args::names::NameKind) -> oxidros_core::error::Result<alloc::string::String>
pub fn Node::fully_qualified_name(&self) -> oxidros_core::error::Result<alloc::string::String>
pub fn Node::gid(&self) -> &[u8; 16]
pub fn Node::name(&self) -> oxidros_core::error::Result<alloc::string::String>
pub fn Node::namespace(&self) -> oxidros_core::error::Result<alloc::string::String>
pub fn Node::node_id(&self) -> u32
```

### QosMapping

```rust
pub struct QosMapping
pub fn QosMapping::congestion_control(profile: &oxidros_core::qos::Profile) -> zenoh_protocol::core::CongestionControl
pub fn QosMapping::effective_depth(profile: &oxidros_core::qos::Profile) -> usize
pub fn QosMapping::is_reliable(profile: &oxidros_core::qos::Profile) -> bool
pub fn QosMapping::is_transient_local(profile: &oxidros_core::qos::Profile) -> bool
pub fn QosMapping::validate(profile: &oxidros_core::qos::Profile)
```

### Selector

```rust
pub type Selector::ActionClient<T: ros2_types::traits::ActionMsg> = selector::ActionClient<T>
pub type Selector::ActionGoalHandle<T: ros2_types::traits::ActionMsg> = selector::ActionGoalHandle<T>
pub type Selector::ActionServer<T: ros2_types::traits::ActionMsg> = selector::ActionServer<T>
pub type Selector::ParameterServer = parameter::ParameterServer
pub struct Selector
pub type Selector::Server<T: ros2_types::traits::ServiceMsg + 'static> = service::server::Server<T>
pub type Selector::Subscriber<T: ros2_types::traits::TypeSupport + 'static> = topic::subscriber::Subscriber<T>
pub fn Selector::add_parameter_server(&mut self, param_server: Self::ParameterServer, handler: alloc::boxed::Box<dyn core::ops::function::FnMut(&mut oxidros_core::parameter::Parameters, alloc::collections::btree::set::BTreeSet<alloc::string::String>)>)
pub fn Selector::add_timer(&mut self, duration: core::time::Duration, handler: alloc::boxed::Box<dyn core::ops::function::FnMut()>) -> u64
pub fn Selector::add_wall_timer(&mut self, name: &str, period: core::time::Duration, handler: alloc::boxed::Box<dyn core::ops::function::FnMut()>) -> u64
pub fn Selector::delete_timer(&mut self, id: u64)
pub fn Selector::remove_timer(&mut self, id: u64)
pub fn Selector::wait(&mut self) -> oxidros_core::error::Result<()>
pub fn Selector::wait_timeout(&mut self, timeout: core::time::Duration) -> oxidros_core::error::Result<bool>
```

### ServiceRequest<T:

```rust
pub struct ServiceRequest<T: ros2_types::traits::ServiceMsg>
```

### parameter

```rust
pub fn parameter::ParameterServer::new(node: alloc::sync::Arc<Node>) -> oxidros_core::error::Result<Self>
pub fn parameter::ParameterServer::node(&self) -> &alloc::sync::Arc<Node>
pub fn parameter::ParameterServer::try_process_once(&mut self) -> bool
```

### service

```rust
pub struct service::Client<T: ros2_types::traits::ServiceMsg>
pub struct service::server::RequestSender<T: ros2_types::traits::ServiceMsg>
pub struct service::Server<T: ros2_types::traits::ServiceMsg>
pub struct service::server::Server<T: ros2_types::traits::ServiceMsg>
pub struct service::ServiceRequest<T: ros2_types::traits::ServiceMsg>
pub fn service::client::Client<T>::gid(&self) -> &[u8; 16]
pub fn service::server::Server<T>::gid(&self) -> &[u8; 16]
pub fn service::client::Client<T>::node(&self) -> &alloc::sync::Arc<Node>
pub fn service::server::Server<T>::node(&self) -> &alloc::sync::Arc<Node>
pub fn service::server::RequestSender<T>::send(self, response: &<T as ros2_types::traits::ServiceMsg>::Response) -> oxidros_core::error::Result<()>
```

### topic

```rust
pub struct topic::Publisher<T>
pub struct topic::Subscriber<T>
pub fn topic::publisher::Publisher<T>::gid(&self) -> &[u8; 16]
pub fn topic::subscriber::Subscriber<T>::gid(&self) -> &[u8; 16]
pub fn topic::publisher::Publisher<T>::node(&self) -> &alloc::sync::Arc<Node>
pub fn topic::subscriber::Subscriber<T>::node(&self) -> &alloc::sync::Arc<Node>
```

---

## RCL-Only APIs

These APIs are specific to `oxidros-rcl`.

### ST<T>

```rust
pub struct ST<T>
pub type ST<T>::Target = T
pub fn ST<T>::new(data: T) -> Self
pub fn ST<T>::unwrap(self) -> T
```

### action

```rust
pub type action::client::AsyncCancelReceiver<'a, T>::Output = T
pub type action::server::AsyncCancelReceiver<'a, T>::Output = T
pub type action::client::AsyncFeedbackReceiver<'a, T>::Output = T
pub type action::client::AsyncGoalReceiver<'a, T>::Output = T
pub type action::server::AsyncGoalReceiver<'a, T>::Output = T
pub type action::client::AsyncResultReceiver<'a, T>::Output = T
pub type action::server::AsyncResultReceiver<'a, T>::Output = T
pub struct action::server::AsyncServer<T: ros2_types::traits::ActionMsg>
pub type action::client::AsyncStatusReceiver<'a, T>::Output = T
pub type action::CancelRequest = rcl::action_msgs__srv__CancelGoal_Request
pub struct action::client::Client<T: ros2_types::traits::ActionMsg>
pub type action::client::ClientCancelRecv<'a, T>::Output = T
pub type action::client::ClientGoalRecv<'a, T>::Output = T
pub struct action::client::ClientQosOption
pub type action::client::ClientResultRecv<'a, T>::Output = T
pub struct action::handle::GoalHandle<T: ros2_types::traits::ActionMsg>
pub type action::SendGoalServiceRequest<T> = <<T as ros2_types::traits::ActionMsg>::Goal as ros2_types::traits::ActionGoal>::Request
pub struct action::server::Server<T: ros2_types::traits::ActionMsg>
pub struct action::server::ServerCancelSend<T: ros2_types::traits::ActionMsg>
pub struct action::server::ServerGoalSend<T: ros2_types::traits::ActionMsg>
pub struct action::server::ServerQosOption
pub struct action::server::ServerResultSend<T: ros2_types::traits::ActionMsg>
pub fn action::handle::GoalHandle<T>::abort(&self) -> oxidros_core::error::Result<()>
pub fn action::server::ServerGoalSend<T>::accept<F>(self, handler: F) -> oxidros_core::error::Result<()> where F: core::ops::function::FnOnce(action::handle::GoalHandle<T>)
pub mod action
pub fn action::handle::GoalHandle<T>::canceled(&self, result: <T as ros2_types::traits::ActionMsg>::ResultContent) -> oxidros_core::error::Result<()>
pub mod action::client
pub fn action::handle::GoalHandle<T>::feedback(&self, content: <T as ros2_types::traits::ActionMsg>::FeedbackContent) -> oxidros_core::error::Result<()>
pub fn action::handle::GoalHandle<T>::finish(&self, result: <T as ros2_types::traits::ActionMsg>::ResultContent) -> oxidros_core::error::Result<()>
pub mod action::handle
pub fn action::handle::GoalHandle<T>::is_canceling(&self) -> oxidros_core::error::Result<bool>
pub fn action::client::Client<T>::is_server_available(&self) -> oxidros_core::error::Result<bool>
pub fn action::handle::GoalHandle<T>::is_terminal(&self) -> oxidros_core::error::Result<bool>
pub fn action::client::Client<T>::new(node: alloc::sync::Arc<node::Node>, action_name: &str, qos: core::option::Option<action::client::ClientQosOption>) -> oxidros_core::error::Result<Self>
pub fn action::server::AsyncServer<T>::new(server: action::server::Server<T>) -> Self
pub fn action::server::Server<T>::new(node: alloc::sync::Arc<node::Node>, action_name: &str, qos: core::option::Option<action::server::ServerQosOption>) -> oxidros_core::error::Result<Self>
pub fn action::client::Client<T>::recv_feedback_timeout(&mut self, t: core::time::Duration, selector: &mut selector::Selector) -> oxidros_core::error::Result<core::option::Option<<T as ros2_types::traits::ActionMsg>::Feedback>>
pub fn action::client::Client<T>::recv_status_timeout(&mut self, t: core::time::Duration, selector: &mut selector::Selector) -> oxidros_core::error::Result<core::option::Option<oxidros_msg::interfaces::action_msgs::msg::goal_status_array::GoalStatusArray>>
pub fn action::server::ServerGoalSend<T>::reject(self) -> oxidros_core::error::Result<()>
pub fn action::server::ServerCancelSend<T>::send(self, accepted_goals: alloc::vec::Vec<oxidros_msg::interfaces::action_msgs::msg::goal_info::GoalInfo>) -> oxidros_core::error::Result<()>
pub fn action::server::ServerResultSend<T>::send(self, uuid: &[u8; 16]) -> oxidros_core::error::Result<()>
pub fn action::client::Client<T>::send_cancel_request(&mut self, request: &oxidros_msg::interfaces::action_msgs::srv::cancel_goal::CancelGoal_Request) -> oxidros_core::error::Result<action::client::ClientCancelRecv<'_, T>>
pub fn action::client::Client<T>::send_goal_with_uuid(&mut self, goal: <T as ros2_types::traits::ActionMsg>::GoalContent, uuid: [u8; 16]) -> oxidros_core::error::Result<action::client::ClientGoalRecv<'_, T>>
pub fn action::client::Client<T>::send_result_request(&mut self, data: &<<T as ros2_types::traits::ActionMsg>::Result as ros2_types::traits::ActionResult>::Request) -> oxidros_core::error::Result<action::client::ClientResultRecv<'_, T>>
pub mod action::server
pub fn action::server::Server<T>::try_recv_cancel_request(&mut self) -> oxidros_core::error::Result<core::option::Option<(action::server::ServerCancelSend<T>, rcl::action_msgs__srv__CancelGoal_Request, alloc::vec::Vec<oxidros_msg::interfaces::action_msgs::msg::goal_info::GoalInfo>)>>
pub fn action::server::Server<T>::try_recv_data(&mut self) -> oxidros_core::error::Result<()>
pub fn action::client::Client<T>::try_recv_feedback(&mut self) -> oxidros_core::error::Result<core::option::Option<<T as ros2_types::traits::ActionMsg>::Feedback>>
pub fn action::server::Server<T>::try_recv_goal_request(&mut self) -> oxidros_core::error::Result<core::option::Option<(action::server::ServerGoalSend<T>, action::SendGoalServiceRequest<T>)>>
pub fn action::server::Server<T>::try_recv_result_request(&mut self) -> oxidros_core::error::Result<core::option::Option<(action::server::ServerResultSend<T>, <<T as ros2_types::traits::ActionMsg>::Result as ros2_types::traits::ActionResult>::Request)>>
pub fn action::client::Client<T>::try_recv_status(&mut self) -> oxidros_core::error::Result<core::option::Option<oxidros_msg::interfaces::action_msgs::msg::goal_status_array::GoalStatusArray>>
```

### clock

```rust
pub struct clock::Clock
pub mod clock
pub fn clock::Clock::drop(&mut self)
pub fn clock::Clock::get_now(&mut self) -> oxidros_core::error::Result<i64>
pub fn clock::Clock::new() -> oxidros_core::error::Result<Self>
```

### context

```rust
pub struct context::Context
pub type context::Context::Node = node::Node
pub type context::Context::Selector = selector::Selector
pub mod context
pub fn context::Context::create_node(self: &alloc::sync::Arc<Self>, name: &str, namespace: core::option::Option<&str>) -> oxidros_core::error::Result<alloc::sync::Arc<node::Node>>
pub fn context::Context::create_node_with_opt(self: &alloc::sync::Arc<Self>, name: &str, namespace: core::option::Option<&str>, options: node::NodeOptions) -> oxidros_core::error::Result<alloc::sync::Arc<node::Node>>
pub fn context::Context::create_selector(self: &alloc::sync::Arc<Self>) -> oxidros_core::error::Result<selector::Selector>
pub fn context::Context::drop(&mut self)
pub fn context::Context::new() -> oxidros_core::error::Result<alloc::sync::Arc<Self>>
pub fn context::Context::new_node(self: &alloc::sync::Arc<Self>, name: &str, namespace: core::option::Option<&str>) -> oxidros_core::error::Result<alloc::sync::Arc<Self::Node>>
pub fn context::Context::new_selector(self: &alloc::sync::Arc<Self>) -> oxidros_core::error::Result<Self::Selector>
pub fn context::Context::ros_domain_id(&self) -> u32
```

### error

```rust
pub mod error
```

### helper

```rust
pub mod helper
```

### is_halt

```rust
pub fn is_halt() -> bool
```

### logger

```rust
pub struct logger::Logger
pub fn logger::Logger::new(name: &str) -> Self
pub fn logger::Logger::write_debug(&self, msg: &str, function_name: &str, file_name: &str, line_number: u64) -> oxidros_core::error::Result<()>
pub fn logger::Logger::write_error(&self, msg: &str, function_name: &str, file_name: &str, line_number: u64) -> oxidros_core::error::Result<()>
pub fn logger::Logger::write_fatal(&self, msg: &str, function_name: &str, file_name: &str, line_number: u64) -> oxidros_core::error::Result<()>
pub fn logger::Logger::write_info(&self, msg: &str, function_name: &str, file_name: &str, line_number: u64) -> oxidros_core::error::Result<()>
pub fn logger::Logger::write_warn(&self, msg: &str, function_name: &str, file_name: &str, line_number: u64) -> oxidros_core::error::Result<()>
```

### msg

```rust
pub mod msg
```

### node

```rust
pub type node::Node::Client<T: ros2_types::traits::ServiceMsg> = service::client::Client<T>
pub struct node::Node
pub struct node::NodeOptions
pub type node::Node::Publisher<T: ros2_types::traits::TypeSupport> = topic::publisher::Publisher<T>
pub type node::Node::Server<T: ros2_types::traits::ServiceMsg> = service::server::Server<T>
pub type node::Node::Subscriber<T: ros2_types::traits::TypeSupport> = topic::subscriber::Subscriber<T>
pub fn node::Node::create_parameter_server(self: &alloc::sync::Arc<Self>) -> oxidros_core::error::Result<parameter::ParameterServer>
pub fn node::Node::drop(&mut self)
pub fn node::NodeOptions::drop(&mut self)
pub fn node::Node::fully_qualified_name(&self) -> oxidros_core::error::Result<alloc::string::String>
pub fn node::Node::name(&self) -> oxidros_core::error::Result<alloc::string::String>
pub fn node::Node::namespace(&self) -> oxidros_core::error::Result<alloc::string::String>
pub fn node::NodeOptions::new() -> Self
pub mod node
```

### parameter

```rust
pub struct parameter::AsyncWait<'a>
pub type parameter::AsyncWait<'a>::IntoFuture = F
pub type parameter::AsyncWait<'a>::Ok = T
pub fn parameter::AsyncWait<'a>::drop(&mut self)
pub fn parameter::ParameterServer::drop(&mut self)
pub fn parameter::AsyncWait<'a>::into_future(self) -> <F as core::future::into_future::IntoFuture>::IntoFuture
pub fn parameter::AsyncWait<'a>::poll(self: core::pin::Pin<&mut Self>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<Self::Output>
pub fn parameter::AsyncWait<'a>::try_poll(self: core::pin::Pin<&mut F>, cx: &mut core::task::wake::Context<'_>) -> core::task::poll::Poll<<F as core::future::future::Future>::Output>
pub fn parameter::ParameterServer::wait(&mut self) -> parameter::AsyncWait<'_>
```

### selector

```rust
pub type selector::Selector::ActionClient<T: ros2_types::traits::ActionMsg> = action::client::Client<T>
pub type selector::Selector::ActionGoalHandle<T: ros2_types::traits::ActionMsg> = action::handle::GoalHandle<T>
pub type selector::Selector::ActionServer<T: ros2_types::traits::ActionMsg> = action::server::Server<T>
pub type selector::Selector::ParameterServer = parameter::ParameterServer
pub struct selector::Selector
pub type selector::Selector::Server<T: ros2_types::traits::ServiceMsg> = service::server::Server<T>
pub type selector::Selector::Subscriber<T: ros2_types::traits::TypeSupport> = topic::subscriber::Subscriber<T>
pub fn selector::Selector::add_parameter_server(&mut self, param_server: Self::ParameterServer, handler: alloc::boxed::Box<dyn core::ops::function::FnMut(&mut oxidros_core::parameter::Parameters, alloc::collections::btree::set::BTreeSet<alloc::string::String>)>)
pub fn selector::Selector::add_timer(&mut self, duration: core::time::Duration, handler: alloc::boxed::Box<dyn core::ops::function::FnMut()>) -> u64
pub fn selector::Selector::add_wall_timer(&mut self, name: &str, period: core::time::Duration, handler: alloc::boxed::Box<dyn core::ops::function::FnMut()>) -> u64
pub fn selector::Selector::delete_timer(&mut self, id: u64)
pub fn selector::Selector::drop(&mut self)
pub fn selector::Selector::remove_timer(&mut self, id: u64)
pub mod selector
pub fn selector::Selector::wait(&mut self) -> oxidros_core::error::Result<()>
pub fn selector::Selector::wait_timeout(&mut self, timeout: core::time::Duration) -> oxidros_core::error::Result<bool>
```

### service

```rust
pub type service::client::AsyncReceiver<'a, T>::Output = T
pub type service::server::AsyncReceiver<'a, T>::Output = T
pub type service::client::ClientRecv<'a, T>::Output = T
pub enum service::server::RCLServiceIntrospection
pub struct service::server::Server<T>
pub struct service::server::ServerSend<T>
pub fn service::server::Server<T>::configure_introspection(&self, clock: &mut oxidros_msg::interfaces::rosgraph_msgs::msg::clock::Clock, qos: oxidros_core::qos::Profile, introspection_state: service::server::RCLServiceIntrospection) -> oxidros_core::error::Result<()>
pub fn service::client::Client<T>::send(&mut self, data: &<T as ros2_types::traits::ServiceMsg>::Request) -> oxidros_core::error::Result<service::client::ClientRecv<'_, T>>
pub fn service::server::ServerSend<T>::send(self, data: &<T as ros2_types::traits::ServiceMsg>::Response) -> oxidros_core::error::Result<()>
pub fn service::client::Client<T>::send_ret_seq(&mut self, data: &<T as ros2_types::traits::ServiceMsg>::Request) -> oxidros_core::error::Result<(service::client::ClientRecv<'_, T>, i64)>
```

### topic

```rust
pub type topic::subscriber::AsyncReceiver<'a, T>::Output = T
pub struct topic::publisher_loaned_message::Copied<T: ros2_types::traits::TypeSupport>
pub struct topic::publisher_loaned_message::Loaned<T: ros2_types::traits::TypeSupport>
pub enum topic::publisher_loaned_message::PublisherLoanedMessage<T: ros2_types::traits::TypeSupport>
pub struct topic::subscriber_loaned_message::SubscriberLoanedMessage<T>
pub type topic::publisher_loaned_message::PublisherLoanedMessage<T>::Target = T
pub type topic::subscriber_loaned_message::SubscriberLoanedMessage<T>::Target = T
pub fn topic::publisher::Publisher<T>::borrow_loaned_message(&self) -> oxidros_core::error::Result<topic::publisher_loaned_message::PublisherLoanedMessage<T>>
pub fn topic::publisher::Publisher<T>::can_loan_messages(&self) -> bool
pub fn topic::publisher::Publisher<T>::drop(&mut self)
pub fn topic::publisher_loaned_message::Loaned<T>::drop(&mut self)
pub fn topic::subscriber_loaned_message::SubscriberLoanedMessage<T>::drop(&mut self)
pub fn topic::publisher_loaned_message::Copied<T>::new(publisher: alloc::sync::Arc<rcl::rcl_publisher_s>) -> Self
pub mod topic::publisher_loaned_message
pub fn topic::publisher::Publisher<T>::send_loaned(&self, msg: topic::publisher_loaned_message::PublisherLoanedMessage<T>) -> oxidros_core::error::Result<()>
pub mod topic::subscriber_loaned_message
```
