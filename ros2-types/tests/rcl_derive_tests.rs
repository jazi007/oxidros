//! Tests for rcl feature code generation
//!
//! These tests verify that the derive macros generate valid code when
//! the `rcl` feature is enabled. Since we don't have actual ROS2 libraries
//! in the test environment, these are compile-only tests.

// Skip this entire test file when derive feature is not enabled
#![cfg(feature = "derive")]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

use ros2_types::{Ros2Msg, TypeDescription};

/// Test struct to verify rcl code generation compiles
#[derive(Debug, Ros2Msg, TypeDescription, serde::Serialize, serde::Deserialize)]
#[ros2(package = "test_msgs", interface_type = "msg")]
#[repr(C)]
pub struct RclTestMsg {
    pub value: i32,
}

/// Service request for rcl test
/// Note: skip_wrapper = true because we generate the wrapper via ros2_service! below
#[derive(Debug, Ros2Msg, TypeDescription, serde::Serialize, serde::Deserialize)]
#[ros2(package = "test_msgs", interface_type = "srv", skip_wrapper = true)]
#[repr(C)]
pub struct RclTest_Request {
    pub input: i64,
}

/// Service response for rcl test
#[derive(Debug, Ros2Msg, TypeDescription, serde::Serialize, serde::Deserialize)]
#[ros2(package = "test_msgs", interface_type = "srv")]
#[repr(C)]
pub struct RclTest_Response {
    pub output: i64,
}

// Generate service wrapper - this should compile with rcl feature
ros2_types::ros2_service!(test_msgs, RclTest);

// Verify the generated types exist
#[test]
fn test_rcl_types_exist() {
    // These types should be generated by the macros
    fn _check_msg_type<T: ros2_types::TypeSupport>() {}

    // With rcl feature, TypeSupport is implemented
    #[cfg(feature = "rcl")]
    {
        _check_msg_type::<RclTestMsg>();
        _check_msg_type::<RclTest_Request>();
        _check_msg_type::<RclTest_Response>();
    }
}

#[test]
fn test_rcl_service_wrapper_exists() {
    // The service wrapper struct should exist
    let _ = std::any::type_name::<RclTest>();

    // With rcl feature, ServiceMsg is implemented
    #[cfg(feature = "rcl")]
    {
        fn _check_service<T: ros2_types::ServiceMsg>() {}
        _check_service::<RclTest>();
    }
}

// Test that TryClone is available with rcl feature
#[cfg(feature = "rcl")]
#[test]
fn test_rcl_try_clone_trait() {
    fn _check_try_clone<T: ros2_types::TryClone>() {}
    _check_try_clone::<RclTestMsg>();
}

// Test that new() method exists with rcl feature
#[cfg(feature = "rcl")]
#[test]
fn test_rcl_new_method() {
    // new() returns Option<Self> with rcl feature
    // We can't actually call it since we don't have the C library
    fn _check_new<T>()
    where
        T: Sized,
    {
        // Just checking the method signature would compile
    }
}

// Test that pure Rust traits are generated without rcl feature
#[cfg(not(feature = "rcl"))]
#[test]
fn test_pure_rust_traits() {
    fn _check_default<T: Default>() {}
    fn _check_clone<T: Clone>() {}
    fn _check_partial_eq<T: PartialEq>() {}

    _check_default::<RclTestMsg>();
    _check_clone::<RclTestMsg>();
    _check_partial_eq::<RclTestMsg>();
}
